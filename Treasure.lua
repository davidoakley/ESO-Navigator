---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by david.
--- DateTime: 27/05/2025 20:21
---

local Nav = Navigator


--- @class TreasureNode
local TreasureNode = Nav.Node:New()

function TreasureNode:GetIcon()
    return string.format("Navigator/media/icons/%s.dds", self.icon)
end

function TreasureNode:GetTagList()
    local tagList = {}

    if self.count > 1 then
        table.insert(tagList, "Ã— "..self.count)
    end

    return Nav.Utils.tableConcat(tagList, Nav.Node.GetTagList(self))
end

function TreasureNode:AddMenuItems()
    AddMenuItem(GetString(NAVIGATOR_MENU_SHOWONMAP), function()
        self:ZoomToPOI(false)
    end)
    AddMenuItem(GetString(NAVIGATOR_MENU_SETDESTINATION), function()
        self:ZoomToPOI(true)
    end)
end

function TreasureNode:GetActions()
    return Nav.saved.poiActions
end

function TreasureNode:ZoomToPOI(setWaypoint, useCurrentZoom)
    local function panToPOI(self, zoneIndex, mapId)
        local normalizedX, normalizedZ = self.map.x, self.map.y --self:GetMapInfo(self, zoneIndex, mapId)
        --Nav.log("Node:ZoomToPOI: poiIndex=%d, %f,%f", self.poiIndex or -1, normalizedX, normalizedZ)
        if setWaypoint then
            PingMap(MAP_PIN_TYPE_PLAYER_WAYPOINT, MAP_TYPE_LOCATION_CENTERED, normalizedX, normalizedZ)
        else
            Nav.Node.AddPing(normalizedX, normalizedZ)
        end

        local mapPanAndZoom = ZO_WorldMap_GetPanAndZoom()
        mapPanAndZoom:PanToNormalizedPosition(normalizedX, normalizedZ, useCurrentZoom)
    end

    local targetMapId = self.mapId or Nav.Locations.GetMapIdByZoneId(self.zoneId)
    local currentMapId = GetCurrentMapId()
    local targetZoneIndex = GetZoneIndex(self.zoneId)
    if self.nodeIndex == 407 then -- Dragonguard Sanctum
        targetMapId = 1654
    end

    if targetMapId ~= currentMapId then
        WORLD_MAP_MANAGER:SetMapById(targetMapId)

        zo_callLater(function()
            panToPOI(self, targetZoneIndex, targetMapId)
        end, 100)
    else
        panToPOI(self, targetZoneIndex, targetMapId)
    end
end

function TreasureNode:GetWeight()
    return self.count
end


--- @class Treasure
local Treasure = {}

local function getItemsData()
    if Treasure.itemsData then
        return Treasure.itemsData
    end

    Treasure.itemsData = { }
    local zones = Nav.Locations:GetZones()
    for zoneId, zone in pairs(zones) do
        local mapId = zone.mapId or Nav.Locations.GetMapIdByZoneId(zoneId)
        local mapIdData = LibTreasure_GetMapIdData(mapId)
        if mapIdData then
            for m = 1, #mapIdData do
                local itemData = mapIdData[m]
                Treasure.itemsData[itemData.itemId] = itemData
            end
        end
    end

    return Treasure.itemsData
end

function Treasure.Load(zones)
    if not LibTreasure_GetItemIdData then -- Check if LibTreasure is available
        return
    end

    local itemsData = getItemsData()

    local beginTime = GetGameTimeMilliseconds()
    local bag = SHARED_INVENTORY:GetOrCreateBagCache(BAG_BACKPACK)
    local mapIndexMap = {}
    for _, slotData in pairs(bag) do
        local itemId = GetItemId(slotData.bagId, slotData.slotIndex)
        local thatMap = itemsData[itemId]
        if thatMap ~= nil then
            local mapID = thatMap.mapId
            local _, _, _,zoneIndex, _ = GetMapInfoById(mapID)

            local treasure = mapIndexMap[zoneIndex]
            if not mapIndexMap[zoneIndex] then
                treasure = Treasure:New()
                mapIndexMap[zoneIndex] = treasure
            end

            treasure:Add(slotData, thatMap)
        end
    end

    for _, zone in pairs(zones) do
        zone.treasure = mapIndexMap[zone.zoneIndex]
    end
    Nav.log("Treasure.Load: %dms", GetGameTimeMilliseconds() - beginTime)
end

function Treasure:New(o)
    o = o or { list = {} }
    setmetatable(o, self)
    self.__index = self
    return o
end

local function getSurveyType(texture)
    local i = 1

    for word in string.gmatch(texture, "[^_]+") do
        if i == 3 then
            return word
        end
        i = i + 1
    end
    return nil
end

function Treasure:Add(slotData, thatMap)
    local pinType = thatMap.pinType
    local itemName = Nav.Utils.FormatSimpleName(GetItemName(slotData.bagId, slotData.slotIndex))
    local icon, stackCount, sellPrice, meetsUsageRequirement, locked, equipType, _, functionalQuality, displayQuality = GetItemInfo(slotData.bagId, slotData.slotIndex)
    local surveyType = nil
    local suffix = ""

    if itemName:sub(-3) == "III" then
        suffix = " III"
        itemName = itemName:sub(1, #itemName - 4)
    elseif itemName:sub(-2) == "II" then
        suffix = " II"
        itemName = itemName:sub(1, #itemName - 3)
    elseif itemName:sub(-1) == "I" then
        suffix = " I"
        itemName = itemName:sub(1, #itemName - 2)
    end

    if pinType == "survey" then
        itemName = itemName:gsub("%s*:.*$", "")

        surveyType = getSurveyType(thatMap.texture)
    end

    itemName = itemName .. suffix

    table.insert(self.list, TreasureNode:New({
        name = itemName,
        icon = surveyType or pinType,
        pinType = pinType,
        surveyType = surveyType,
        count = stackCount,
        mapId = thatMap.mapId,
        known = true,
        map = thatMap,
        slotData = slotData
    }))
end


function Treasure:GetCount(splitSurveys)
    local result = {}

    for i = 1, #self.list do
        local item = self.list[i]
        local category = splitSurveys and item.surveyType or item.pinType
        result[category] = (result[category] or 0) + item.count
    end

    return result
end

function Treasure:GetList()
    return self.list
end

Nav.Treasure = Treasure
Nav.TreasureNode = TreasureNode