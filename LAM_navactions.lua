---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by david.
--- DateTime: 21/02/2025 09:19
---

--[[dropdownData = {
    type = "dropdown",
    name = "My Dropdown", -- or string id or function returning a string
    choices = {"table", "of", "choices"},
    choicesValues = {"foo", 2, "three"}, -- if specified, these values will get passed to setFunc instead (optional)
    getFunc = function() return db.var end,
    setFunc = function(var) db.var = var doStuff() end,
    tooltip = "Dropdown's tooltip text.", -- or string id or function returning a string (optional)
    choicesTooltips = {"tooltip 1", "tooltip 2", "tooltip 3"}, -- or array of string ids or array of functions returning a string (optional)
    width = "full", -- or "half" (optional)
    scrollable = true, -- boolean or number, if set the dropdown will feature a scroll bar if there are a large amount of choices and limit the visible lines to the specified number or 10 if true is used (optional)
    disabled = function() return db.someBooleanSetting end, -- or boolean (optional)
    warning = "May cause permanent awesomeness.", -- or string id or function returning a string (optional)
    requiresReload = false, -- boolean, if set to true, the warning text will contain a notice that changes are only applied after an UI reload and any change to the value will make the "Apply Settings" button appear on the panel which will reload the UI when pressed (optional)
    default = defaults.var, -- default value or function that returns the default value (optional)
    helpUrl = "https://www.esoui.com/portal.php?id=218&a=faq", -- a string URL or a function that returns the string URL (optional)
    reference = "MyAddonDropdown", -- unique global reference to control (optional)
    resetFunc = function(dropdownControl) d("defaults reset") end, -- custom function to run after the control is reset to defaults (optional)
} ]]


local widgetVersion = 27
local LAM = LibAddonMenu2
if not LAM:RegisterWidget("nav_actions", widgetVersion) then return end

--local GetDefaultValue = LAM.util.GetDefaultValue

local wm = WINDOW_MANAGER

local DEFAULT_VISIBLE_ROWS = 10
local PADDING_Y = ZO_SCROLLABLE_COMBO_BOX_LIST_PADDING_Y
local ROUNDING_MARGIN = 0.01 -- needed to avoid rare issue with too many anchors processed
local SCROLLBAR_PADDING = ZO_SCROLL_BAR_WIDTH
local PADDING_X = GetMenuPadding()
local CONTENT_PADDING = PADDING_X * 4


--local function UpdateDisabled(control)
--    local disable
--    if type(control.data.disabled) == "function" then
--        disable = control.data.disabled()
--    else
--        disable = control.data.disabled
--    end
--
--    control.dropdown:SetEnabled(not disable)
--    if disable then
--        control.label:SetColor(ZO_DEFAULT_DISABLED_COLOR:UnpackRGBA())
--    else
--        control.label:SetColor(ZO_DEFAULT_ENABLED_COLOR:UnpackRGBA())
--    end
--end

local function UpdateValue(dropdown, index, forceDefault, value)
    if forceDefault then --if we are forcing defaults
        local def_value = dropdown.control.data.default(index)

        dropdown.control.data.setFunc(index, def_value)
        dropdown:SetSelectedItem(dropdown.control.choices[def_value])
    elseif value ~= nil then
        dropdown.control.data.setFunc(index, value)
        --after setting this value, let's refresh the others to see if any should be disabled or have their settings changed
        LAM.util.RequestRefreshIfNeeded(dropdown.control)
    else
        value = dropdown.control.data.getFunc(index)
        dropdown:SetSelectedItem(dropdown.choices[value])
    end
end

local function DropdownCallback(_, choiceText, choice)
    local updateValue = choice.value
    if updateValue == nil then updateValue = choiceText end
    choice.dropdown:UpdateValue(choice.dropdown.index, false, updateValue)
end

local function DoShowTooltip(control, tooltip)
    local tooltipText = LAM.util.GetStringFromValue(tooltip)
    if tooltipText ~= nil and tooltipText ~= "" then
        InitializeTooltip(InformationTooltip, control, TOPLEFT, 0, 0, BOTTOMRIGHT)
        SetTooltipText(InformationTooltip, tooltipText)
        InformationTooltipTopLevel:BringWindowToTop()
    end
end

local function ShowTooltip(control)
    DoShowTooltip(control, control.dataEntry.data.tooltip)
end

local function HideTooltip()
    ClearTooltip(InformationTooltip)
end

local function SetupTooltips(comboBox)
    SecurePostHook(ZO_ComboBoxDropdown_Keyboard, "OnEntryMouseEnter", function(comboBoxRowCtrl)
        local lComboBox = comboBoxRowCtrl.m_owner
        if lComboBox ~= nil and lComboBox == comboBox then
            ShowTooltip(comboBoxRowCtrl)
        end
    end)

    SecurePostHook(ZO_ComboBoxDropdown_Keyboard, "OnEntryMouseExit", function(_)
        HideTooltip()
    end)
end

local function UpdateChoices(dropdown, index, choicesFn, choicesValuesFn, choicesTooltipsFn)
    dropdown:ClearItems() --remove previous choices --(need to call :SetSelectedItem()?)
    ZO_ClearTable(dropdown.choices)

    local choices = choicesFn(index)
    local choicesValues = choicesValuesFn and choicesValuesFn(index)
    local choicesTooltips = choicesTooltipsFn and choicesTooltipsFn(index)

    --build new list of choices
    --choices = choices or control.data.choices
    --choicesValues = choicesValues or control.data.choicesValues
    --choicesTooltips = choicesTooltips or control.data.choicesTooltips

    if choicesValues then
        assert(#choices == #choicesValues, "choices and choicesValues need to have the same size")
    end

    if choicesTooltips then
        assert(#choices == #choicesTooltips, "choices and choicesTooltips need to have the same size")
        SetupTooltips(dropdown)
    end

    for i = 1, #choices do
        local entry = dropdown:CreateItemEntry(choices[i], DropdownCallback)
        entry.control = dropdown.control
        entry.dropdown = dropdown
        if choicesValues then
            entry.value = choicesValues[i]
        end
        if choicesTooltips then
            entry.tooltip = choicesTooltips[i]
        end
        local entryValue = entry.value
        if entryValue == nil then entryValue = entry.name end
        dropdown.choices[entryValue] = entry.name

        dropdown:AddItem(entry, ZO_COMBOBOX_SUPRESS_UPDATE) --if sort type/order isn't specified, then don't sort
    end
end

--Change the height of the combobox dropdown
local function SetDropdownHeight(_, dropdown, dropdownData)
    local entrySpacing = dropdown:GetSpacing()
    local numSortedItems = #dropdown.m_sortedItems
    local visibleRows, min, max

    local isScrollable = dropdownData.scrollable
    visibleRows = type(dropdownData.scrollable) == "number" and dropdownData.scrollable or DEFAULT_VISIBLE_ROWS
    --Either scrollable combobox: Show number of entries passed in by the data.scrollable, or use default number of entries (10)
    --but if less than default number of entries in the dropdown list, then shrink the max value to the number of entrries!
    if numSortedItems < visibleRows then
        min = numSortedItems
        max = numSortedItems
    else
        if isScrollable then
            min = (DEFAULT_VISIBLE_ROWS < visibleRows and DEFAULT_VISIBLE_ROWS) or visibleRows
            max = (DEFAULT_VISIBLE_ROWS > visibleRows and DEFAULT_VISIBLE_ROWS) or visibleRows
        else
            --Or show all entries if no scrollbar is requested
            min = DEFAULT_VISIBLE_ROWS
            max = numSortedItems
        end
    end

    --Entries to actually calculate the height = "number of sorted items" * "template height" + "number of sorted items -1" * spacing (last item got no spacing)
    local numEntries = zo_clamp(numSortedItems, min, max)
    local entryHeightWithSpacing
    if GetAPIVersion() < 101041 then
        entryHeightWithSpacing = dropdown:GetEntryTemplateHeightWithSpacing()
    else
        entryHeightWithSpacing = ZO_COMBO_BOX_ENTRY_TEMPLATE_HEIGHT + dropdown.m_dropdownObject.spacing
    end
    local allItemsHeight = (entryHeightWithSpacing * numEntries) - entrySpacing + (PADDING_Y * 2) + ROUNDING_MARGIN
    dropdown:SetHeight(allItemsHeight)
    ZO_ScrollList_Commit(dropdown.m_scroll)

    return visibleRows, min, max
end

local function CalculateContentWidth(dropdown)
    local dataType = ZO_ScrollList_GetDataTypeTable(dropdown.m_scroll, 1)

    local dummy = dataType.pool:AcquireObject()
    local item = {
        m_owner = dropdown,
        name = "Dummy"
    }
    if GetAPIVersion() >= 101041 then
        item = dropdown.m_dropdownObject:CreateScrollableEntry(item, 1, 1)
    end
    dataType.setupCallback(dummy, item, dropdown)

    local maxWidth = 0
    local label = dummy.m_label
    local entries = dropdown.m_sortedItems
    local numItems = #entries
    for index = 1, numItems do
        label:SetText(entries[index].name)
        local width = label:GetTextWidth()
        if (width > maxWidth) then
            maxWidth = width
        end
    end

    dataType.pool:ReleaseObject(dummy.key)
    return maxWidth
end

local function AdjustDimensions(control, dropdown, dropdownData)
    local numItems = #dropdown.m_sortedItems
    local dropdownObject = dropdown.m_dropdown
    local scroll = dropdownObject:GetNamedChild("Scroll")
    local scrollContent = scroll:GetNamedChild("Contents")
    local anchorOffset = 0

    local contentWidth = CalculateContentWidth(dropdown) + CONTENT_PADDING
    local visibleRows = SetDropdownHeight(control, dropdown, dropdownData)

    local hasScrollbar = false
    if numItems > visibleRows then
        numItems = visibleRows
        hasScrollbar = true
    end

    if hasScrollbar then
        contentWidth = contentWidth + SCROLLBAR_PADDING
        anchorOffset = -SCROLLBAR_PADDING
    end

    local width = zo_max(contentWidth, dropdown.m_container:GetWidth())
    dropdownObject:SetWidth(width)

    scrollContent:SetAnchor(BOTTOMRIGHT, nil, nil, anchorOffset)
end

local function GetStringFromValue(value)
    if type(value) == "function" then
        return value()
    elseif type(value) == "number" then
        return GetString(value)
    end
    return value
end

function LAMCreateControl.nav_actions(parent, dropdownData, controlName)

    local control = LAM.util.CreateBaseControl(parent, dropdownData, controlName)
    local width = control:GetWidth()
    control:SetResizeToFitDescendents(true)

    local actionCount = #dropdownData.actions
    local rowHeight = 27

    local gap = 12
    local dropdownW, dropdownH = width / 3 - gap, rowHeight --control.container:GetDimensions()

    local height = dropdownH * (actionCount + 1) + gap * actionCount

    control:SetDimensionConstraints(width, height, width, height)
    control:SetResizeToFitConstrains(ANCHOR_CONSTRAINS_Y)

    control.data.tooltipText = GetStringFromValue(control.data.tooltip)
    control:SetMouseEnabled(true)
    control:SetHandler("OnMouseEnter", ZO_Options_OnMouseEnter)
    control:SetHandler("OnMouseExit", ZO_Options_OnMouseExit)

    local countControl = parent
    local name = parent:GetName()
    if not name or #name == 0 then
        countControl = LAMCreateControl
        name = "LAM"
    end

    local dropdownOriginX = width - dropdownW -- * columns - gap * (columns - 1)
    local dropdownOriginY = rowHeight
    control.comboboxes = {}
    control.dropdowns = {}

    -- Heading label
    local label = wm:CreateControl(nil, control, CT_LABEL)
    label:SetFont("ZoFontWinH3")
    label:SetHeight(rowHeight)
    label:SetWrapMode(TEXT_WRAP_MODE_ELLIPSIS)
    label:SetText(LAM.util.GetStringFromValue(dropdownData.name))
    label:SetAnchor(TOPLEFT, control, TOPLEFT, 0, 0)
    label:SetAnchor(TOPRIGHT, control, TOPRIGHT, 0, 0)
    control.label = label

    local index = 1
    for row = 1, actionCount do
        local y = dropdownOriginY + gap + (rowHeight + gap) * (row - 1)
        local rowLabel = wm:CreateControl(nil, control, CT_LABEL)
        rowLabel:SetFont("ZoFontWinH4")
        rowLabel:SetHeight(rowHeight)
        rowLabel:SetWrapMode(TEXT_WRAP_MODE_ELLIPSIS)
        rowLabel:SetText(LAM.util.GetStringFromValue(dropdownData.actions[row]))
        rowLabel:SetAnchor(TOPLEFT, nil, nil, 20, y)
        --control.rowLabel = label

        local comboboxCount = (countControl.comboboxCount or 0) + 1
        countControl.comboboxCount = comboboxCount
        local combobox = wm:CreateControlFromVirtual(zo_strjoin(nil, name, "Combobox", comboboxCount), control, "ZO_ComboBox")
        table.insert(control.comboboxes, combobox)

        combobox:SetAnchor(TOPLEFT, nil, nil, dropdownOriginX, y)
        combobox:SetDimensions(dropdownW, dropdownH)
        combobox:SetHandler("OnMouseEnter", function() ZO_Options_OnMouseEnter(control) end)
        combobox:SetHandler("OnMouseExit", function() ZO_Options_OnMouseExit(control) end)

        local dropdown = ZO_ComboBox_ObjectFromContainer(combobox)
        table.insert(control.dropdowns, dropdown)
        dropdown.control = control
        dropdown.index = index
        dropdown.choices = {}
        dropdown:SetSortsItems(false) -- need to sort ourselves in order to be able to sort by value

        dropdown:DisableMultiSelect()

        --After the items are added and the dropdown shows: Change the height of the dropdown
        SecurePostHook(dropdown, "AddMenuItems", function()
            control.AdjustDimensions(control, dropdown, dropdownData)
        end)

        ZO_PreHook(dropdown, "UpdateItems", function(self)
            assert(not self.m_sortsItems, "built-in dropdown sorting was reactivated, sorting is handled by LAM")
            if control.m_sortOrder ~= nil and control.m_sortType then
                local sortKey = next(control.m_sortType)
                local sortFunc = function(item1, item2) return ZO_TableOrderingFunction(item1, item2, sortKey, control.m_sortType, control.m_sortOrder) end
                table.sort(self.m_sortedItems, sortFunc)
            end
        end)

        dropdown.UpdateChoices = UpdateChoices
        dropdown:UpdateChoices(index, dropdownData.choices, dropdownData.choicesValues, dropdownData.choicesTooltips)

        dropdown.UpdateValue = UpdateValue
        dropdown:UpdateValue(index)

        index = index + 1
    end

    if dropdownData.choicesValues then
        control.m_sortType, control.m_sortOrder = ZO_SORT_ORDER_UP, SORT_BY_VALUE
    end

    control.SetDropdownHeight = SetDropdownHeight
    control.AdjustDimensions = AdjustDimensions
    --if dropdownData.disabled ~= nil then
    --    control.UpdateDisabled = UpdateDisabled
    --    control:UpdateDisabled()
    --end

    LAM.util.RegisterForRefreshIfNeeded(control)
    LAM.util.RegisterForReloadIfNeeded(control)

    return control
end
