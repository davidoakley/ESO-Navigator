---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by david.
--- DateTime: 23/12/2025 20:10
---

local Nav = Navigator


--- @class QuestNode
local QuestNode = Nav.Node:New()

function QuestNode:GetIcon()
    if self.icon ~= nil then
        return self.icon
    else
        return "Navigator/media/icons/quest.dds"
    end
end

function QuestNode:GetWeight()
    return self.tracked and 1.0 or 0.0
end

function QuestNode:GetColour(isSelected)
    if self.tracked then
        return Nav.COLOUR_WHITE
    else
        return Nav.Node.GetColour(self, isSelected)
    end
end

function QuestNode:GetIconColour()
    if self.repeatable then
        return Nav.COLOUR_REPEATABLE
    else
        return Nav.COLOUR_WHITE
    end
end

function QuestNode:AddMenuItems()
    AddMenuItem(GetString(NAVIGATOR_MENU_SELECT_QUEST), function()
        self:Select()
    end)

    AddMenuItem(GetString(SI_ITEM_ACTION_SHOW_QUEST), function()
        SYSTEMS:GetObject("questJournal"):OpenQuestJournalToQuest(self.questIndex)
    end)

    if GetIsQuestSharable(self.questIndex) and IsUnitGrouped("player") then
        AddMenuItem(GetString(SI_QUEST_JOURNAL_SHARE), function()
            QUEST_JOURNAL_MANAGER:ShareQuest(self.questIndex)
        end)
    end

    if CanAbandonJournalQuest(self.questIndex) then
        AddMenuItem(GetString(SI_QUEST_JOURNAL_ABANDON), function()
            QUEST_JOURNAL_MANAGER:ConfirmAbandonQuest(self.questIndex)
        end)
    end
end

function QuestNode:GetActions()
    return { singleClick = Nav.ACTION_SELECT, doubleClick = nil }
end

function QuestNode:DoAction(action)
    if action == Nav.ACTION_SELECT then
        self:Select()
    end
end

function QuestNode:GetActionDescription(action)
    if action == Nav.ACTION_SELECT then
        return GetString(NAVIGATOR_MENU_SELECT_QUEST)
    else
        return Nav.Node.GetActionDescription(self, action)
    end
end

local function zoomToQuestPins(self, attempts)
    local pinManager = ZO_WorldMap_GetPinManager()
    local mapPanAndZoom = ZO_WorldMap_GetPanAndZoom()

    local pins = {}
    pinManager:AddPinsToArray(pins, "quest", self.questIndex)
    Nav.questPins = pins

    if pins ~= nil and #pins > 0 then
        Nav.log("Found quest pins: %d after %d attempts", #pins, attempts or 0)
        local normalizedX, normalizedZ = pins[1]:GetNormalizedPosition()
        mapPanAndZoom:PanToNormalizedPosition(normalizedX, normalizedZ, false)
    elseif attempts == nil or attempts < 5 then
        zo_callLater(function()
            -- If the quest pin hasn't been added to the zone map yet, try again in 0.1s
            zoomToQuestPins(self, (attempts or 0) + 1)
        end, 100)
    else
        Nav.log("Failed to find quest pins after 5 attempts")
    end
end

function QuestNode:Select()
    ZO_ZoneStories_Manager.SetTrackedZoneStoryAssisted(false)
    FOCUSED_QUEST_TRACKER:ForceAssist(self.questIndex)

    local targetMapId = Nav.Locations.GetMapIdByZoneId(self.zoneId)
    --local targetMapId = self.mapId or Nav.Locations.GetMapIdByZoneId(self.zoneId)
    local currentMapId = GetCurrentMapId()
    local targetZoneIndex = GetZoneIndex(self.zoneId)
    if self.nodeIndex == 407 then -- Dragonguard Sanctum
        targetMapId = 1654
    end

    --if targetMapId ~= currentMapId then
        -- Allow time for the new quest to be registered before switching zones
        zo_callLater(function()
            WORLD_MAP_MANAGER:SetMapById(targetMapId)
            zoomToQuestPins(self)
        end, 100)
    --else
    --    zoomToQuestPins(self)
    --end

    Nav.mainTab:ImmediateRefresh(Nav.REFRESH_REBUILD)
    if Nav.questTab then
        Nav.questTab:ImmediateRefresh(Nav.REFRESH_REBUILD)
    end
end

function QuestNode:GetTooltipLines()
    local lines = {}

    local _, bgText, stepText, stepType, stepOverrideText, completed, tracked = GetJournalQuestInfo(self.questIndex)

    if completed then
        --AddConditionLine(self, labels, GetJournalQuestEnding(questIndex))
        table.insert(lines, { text = GetJournalQuestEnding(self.questIndex) })
        --self.tooltip:AddLine(GetJournalQuestEnding(questIndex), "", ZO_TOOLTIP_DEFAULT_COLOR:UnpackRGB())
    else
        local tasks = {}
        QUEST_JOURNAL_MANAGER:BuildTextForTasks(stepOverrideText, self.questIndex, tasks)

        for i = 1, #tasks do
            --AddConditionLine(self, labels, tasks[i].name)
            --self.tooltip:AddLine(tasks[i].name, "", ZO_TOOLTIP_DEFAULT_COLOR:UnpackRGB())
            table.insert(lines, { text = tasks[i].name })
        end
    end

    return lines
end

--- @class Quest
local Quest = {
    cache = {}
}

local questTypeMap = {
    [QUEST_TYPE_MAIN_STORY] = { "~MainStory", SI_QUESTTYPE2, 1, true },
    [QUEST_TYPE_HOLIDAY_EVENT] = { "~Holiday", SI_QUESTTYPE12, 9, true },
    [QUEST_TYPE_DUNGEON] = { "~Group", NAVIGATOR_CATEGORY_GROUPCONTENT, 10, false },
    [QUEST_TYPE_RAID] = { "~Group", NAVIGATOR_CATEGORY_GROUPCONTENT, 10, false },
    [QUEST_TYPE_GUILD] = { "~Guild", SI_QUESTTYPE3, 11, false },
    [QUEST_TYPE_UNDAUNTED_PLEDGE] = { "~Guild", SI_QUESTTYPE3, 11, false },
    [QUEST_TYPE_BATTLEGROUND] = { "~Battleground", SI_QUESTTYPE13, 12, false },
    [QUEST_TYPE_PROLOGUE] = { "~Prologue", SI_QUESTTYPE14, 14, true },
    [QUEST_TYPE_COMPANION] = { "~Companion", SI_QUESTTYPE16, 15, true },
    [QUEST_TYPE_TRIBUTE] = { "~Tribute", SI_QUESTTYPE17, 16, true },
    [QUEST_TYPE_SCRIBING] = { "~Scribing", SI_QUESTTYPE18, 17, true },
    [QUEST_TYPE_CRAFTING] = { "~Crafting", SI_QUESTTYPE4, 20, false },
}

local function getQuestCategory(questType, zoneName, zoneId)
    if questTypeMap[questType] ~= nil then
        return unpack(questTypeMap[questType])
    elseif zoneName ~= nil and zoneName ~= "" then
        return "Zone" .. zoneName, zoneName, (zoneId == Nav.currentZoneId and 5 or 6), false
    else
        return "~Other", SI_QUEST_JOURNAL_GENERAL_CATEGORY, 100, true
    end

end

function Quest:BuildQuestCategories()
    local categoryMap = {}

    for questIndex = 1, MAX_JOURNAL_QUESTS do
        if IsValidQuestIndex(questIndex) then
            local questName, _, _, _, _, _, tracked = GetJournalQuestInfo(questIndex)
            local _, _, questZoneIndex, poiIndex = GetJournalQuestLocationInfo(questIndex)
            --Nav.log("%d: '%s' z:%d poi:%d", questIndex, questName or "nil", questZoneIndex, poiIndex or -1)
            local questJournalObject = SYSTEMS:GetObject("questJournal")
            local questMapId

            local questZoneId = GetZoneId(questZoneIndex)
            local questZoneName = GetZoneNameById(questZoneId)
            if questZoneId ~= 0 then
                -- get exact quest location
                questZoneId, questMapId = self:GetQuestZoneId(questIndex)
            end

            local zoneId = Nav.Locations:IsZone(questZoneId) and questZoneId or GetParentZoneId(questZoneId)

            local zoneName = zoneId ~= nil and GetZoneNameById(zoneId) or nil

            local questType = GetJournalQuestType(questIndex)
            local zoneDisplayType = GetJournalQuestZoneDisplayType(questIndex)
            local iconTexture = questJournalObject:GetIconTexture(questType, zoneDisplayType)
            local zoneMapId = Nav.Locations.GetMapIdByZoneId(questZoneId)
            local repeatableType = GetJournalQuestRepeatType(questIndex)

            local node = Nav.QuestNode:New({
                name = questName,
                icon = iconTexture,
                zoneId = zoneId,
                mapId = zoneMapId,
                known = true,
                questIndex = questIndex,
                tracked = tracked,
                repeatable = repeatableType ~= QUEST_REPEAT_NOT_REPEATABLE
            })

            local categoryId, categoryTitle, categoryOrder, showZone = getQuestCategory(questType, zoneName, zoneId)

            if showZone and zoneName ~= nil then
                node.suffix = zoneName
            elseif categoryId == "~Group" then
                node.suffix = questZoneName
            end

            --if Nav.isDeveloper then
            --    node.suffix = (node.suffix or "") .. string.format("[%d]", questType)
            --end

            if categoryMap[categoryId] == nil then
                categoryMap[categoryId] = {
                    id = categoryId,
                    title = categoryTitle,
                    list = {},
                    order = categoryOrder
                }
            end

            table.insert(categoryMap[categoryId].list, node)
        end
    end

    local categoryList = {}
    for _, v in pairs(categoryMap) do
        table.insert(categoryList, v)
    end

    local function comparison(a, b)
        if a.order ~= b.order then
            return a.order < b.order
        end
        return a.id < b.id
    end

    table.sort(categoryList, comparison)

    Quest.categoryMap = categoryMap -- Keep a copy for debugging

    return categoryList
end

function Quest:GetQuestZoneId(questIndex)
    --local questName, _, _, _, _, _, _ = GetJournalQuestInfo(questIndex)

    if self.cache[questIndex] ~= nil then
        -- Quest data did not change: use data from cache
        return self.cache[questIndex]["zoneId"]
    else
    --    -- Get location info
        local result = Quest.SetMapToQuest(questIndex)
        local questZoneId = GetZoneId(GetCurrentMapZoneIndex())
        local mapId = GetCurrentMapId()
    --    -- set map back to player location
        SetMapToPlayerLocation()
        --CALLBACK_MANAGER:FireCallbacks("OnWorldMapChanged")
    --
    --    -- save location data into cache
        self.cache[questIndex] = {}
        self.cache[questIndex]["zoneId"] = questZoneId
    --
        return questZoneId, mapId
    end
end

function Quest.ClearCache()
    Quest.cache = {}
end

-- set map to actual quest location depending on the active step and conditions
-- code is based on the function "ZO_WorldMap_ShowQuestOnMap(questIndex)"
-- https://esoapi.uesp.net/100028/src/ingame/map/worldmap.lua.html#6838
function Quest.SetMapToQuest(questIndex)
    --first try to set the map to one of the quest's step pins
    local result = SET_MAP_RESULT_FAILED
    for stepIndex = QUEST_MAIN_STEP_INDEX, GetJournalQuestNumSteps(questIndex) do
        --Loop through the conditions, if there are any. Prefer non-completed conditions to completed ones.
        local requireNotCompleted = true
        local conditionsExhausted = false
        while result == SET_MAP_RESULT_FAILED and not conditionsExhausted do
            for conditionIndex = 1, GetJournalQuestNumConditions(questIndex, stepIndex) do
                local tryCondition = true
                if requireNotCompleted then
                    local complete = select(4, GetJournalQuestConditionValues(questIndex, stepIndex, conditionIndex))
                    tryCondition = not complete
                end
                if tryCondition then
                    result = SetMapToQuestCondition(questIndex, stepIndex, conditionIndex)
                    if result ~= SET_MAP_RESULT_FAILED then
                        break
                    end
                end
            end
            if requireNotCompleted then
                requireNotCompleted = false
            else
                conditionsExhausted = true
            end
        end
        if result ~= SET_MAP_RESULT_FAILED then
            break
        end
        --If it's the end, set the map to the ending location (Endings don't have conditions)
        if IsJournalQuestStepEnding(questIndex, stepIndex) then
            result = SetMapToQuestStepEnding(questIndex, stepIndex)
            if result ~= SET_MAP_RESULT_FAILED then
                break
            end
        end
    end
    --if it has no condition pins, set it to the quest's zone
    if result == SET_MAP_RESULT_FAILED then
        result = SetMapToQuestZone(questIndex)
    end
    --if that doesn't work, bail
    if result == SET_MAP_RESULT_FAILED then
        --ZO_Alert(UI_ALERT_CATEGORY_ERROR, SOUNDS.NEGATIVE_CLICK, SI_WORLD_MAP_NO_QUEST_MAP_LOCATION)
        return nil
    end

    return result
end


--function Quest:New(o)
--    o = o or { list = {} }
--    setmetatable(o, self)
--    self.__index = self
--    return o
--end


Nav.QuestNode = QuestNode
Nav.Quest = Quest