---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by david.
--- DateTime: 23/12/2025 20:10
---

local Nav = Navigator


--- @class QuestNode
local QuestNode = Nav.Node:New()

function QuestNode:GetIcon()
    if self.icon ~= nil then
        return self.icon
    else
        return "Navigator/media/icons/quest.dds"
    end
end

function QuestNode:GetOverlayIcon()
    if self.tracked then
        return "Navigator/media/overlays/star.dds", Nav.COLOUR_WHITE
    else
        return nil, nil
    end
end

function QuestNode:GetWeight()
    return self.tracked and 1.0 or 0.0
end

function QuestNode:GetColour(isSelected)
    if self.tracked then
        return Nav.COLOUR_WHITE
    else
        return Nav.Node.GetColour(self, isSelected)
    end
end

function QuestNode:GetActions()
    return { singleClick = Nav.ACTION_SHOWONMAP, doubleClick = Nav.ACTION_TRAVEL }
end

function QuestNode:ZoomToQuestPins(attempts)
    local pinManager = ZO_WorldMap_GetPinManager()
    local mapPanAndZoom = ZO_WorldMap_GetPanAndZoom()

    local pins = {}
    pinManager:AddPinsToArray(pins, "quest", self.questIndex)
    Nav.questPins = pins
    --return pins ~= nil and #pins > 0 and pins[1] or nil --ZO_WorldMapPins_Manager:GetQuestConditionPin(self.questIndex)

    if pins ~= nil and #pins > 0 then
        Nav.log("Found quest pins: %d after %d attempts", #pins, attempts or 0)
        local normalizedX, normalizedZ = pins[1]:GetNormalizedPosition()
        mapPanAndZoom:PanToNormalizedPosition(normalizedX, normalizedZ, false)
    elseif attempts == nil or attempts < 20 then
        zo_callLater(function()
            self:ZoomToQuestPins((attempts or 0) + 1)
        end, 100)
    else
        Nav.log("Failed to find quest pins after 20 attempts")
    end
end

function QuestNode:ZoomToPOI(setWaypoint, useCurrentZoom)
    --local function panToPOI(self, zoneIndex, mapId)
    --    local normalizedX, normalizedZ = self.map.x, self.map.y --self:GetMapInfo(self, zoneIndex, mapId)
    --    --Nav.log("Node:ZoomToPOI: poiIndex=%d, %f,%f", self.poiIndex or -1, normalizedX, normalizedZ)
    --    if setWaypoint then
    --        PingMap(MAP_PIN_TYPE_PLAYER_WAYPOINT, MAP_TYPE_LOCATION_CENTERED, normalizedX, normalizedZ)
    --    else
    --        Nav.Node.AddPing(normalizedX, normalizedZ)
    --    end
    --
    --    local mapPanAndZoom = ZO_WorldMap_GetPanAndZoom()
    --    mapPanAndZoom:PanToNormalizedPosition(normalizedX, normalizedZ, useCurrentZoom)
    --end

    ZO_ZoneStories_Manager.SetTrackedZoneStoryAssisted(false)
    FOCUSED_QUEST_TRACKER:ForceAssist(self.questIndex)

    local targetMapId = Nav.Locations.GetMapIdByZoneId(self.zoneId)
    --local targetMapId = self.mapId or Nav.Locations.GetMapIdByZoneId(self.zoneId)
    local currentMapId = GetCurrentMapId()
    local targetZoneIndex = GetZoneIndex(self.zoneId)
    if self.nodeIndex == 407 then -- Dragonguard Sanctum
        targetMapId = 1654
    end

    if targetMapId ~= currentMapId then
        WORLD_MAP_MANAGER:SetMapById(targetMapId)
    end
    self:ZoomToQuestPins()

    Nav.MapTab:ImmediateRefresh()
end

function QuestNode:GetTooltipLines()
    local lines = {}

    local _, bgText, stepText, stepType, stepOverrideText, completed, tracked = GetJournalQuestInfo(self.questIndex)

    if completed then
        --AddConditionLine(self, labels, GetJournalQuestEnding(questIndex))
        table.insert(lines, { text = GetJournalQuestEnding(self.questIndex) })
        --self.tooltip:AddLine(GetJournalQuestEnding(questIndex), "", ZO_TOOLTIP_DEFAULT_COLOR:UnpackRGB())
    else
        local tasks = {}
        QUEST_JOURNAL_MANAGER:BuildTextForTasks(stepOverrideText, self.questIndex, tasks)

        for i = 1, #tasks do
            --AddConditionLine(self, labels, tasks[i].name)
            --self.tooltip:AddLine(tasks[i].name, "", ZO_TOOLTIP_DEFAULT_COLOR:UnpackRGB())
            table.insert(lines, { text = tasks[i].name })
        end
    end

    return lines
end

--- @class Quest
local Quest = {
    cache = {}
}

function Quest:GetQuestNodeList()
    local list = {}

    for questIndex = 1, GetNumJournalQuests() do
        local questName, _, _, _, _, _, tracked = GetJournalQuestInfo(questIndex)
        local _, _, questZoneIndex = GetJournalQuestLocationInfo(questIndex)
        local questJournalObject = SYSTEMS:GetObject("questJournal")
        local questMapId

        local questZoneId = GetZoneId(questZoneIndex)
        if questZoneId ~= 0 then
            -- get exact quest location
            questZoneId, questMapId = self:GetQuestZoneId(questIndex)
        end

        local zoneId = Nav.Locations:IsZone(questZoneId) and questZoneId or GetParentZoneId(questZoneId)

        local zoneName = zoneId ~= nil and GetZoneNameById(zoneId) or nil

        local questType = GetJournalQuestType(questIndex)
        local zoneDisplayType = GetJournalQuestZoneDisplayType(questIndex)
        local iconTexture = questJournalObject:GetIconTexture(questType, zoneDisplayType)
        local zoneMapId = Nav.Locations.GetMapIdByZoneId(questZoneId)

        table.insert(list, Nav.QuestNode:New({
            name = questName,
            icon = iconTexture,
            suffix = zoneName,
            --pinType = pinType,
            --surveyType = surveyType,
            --count = stackCount,
            zoneId = zoneId,
            mapId = zoneMapId,
            known = true,
            questIndex = questIndex,
            tracked = tracked
            --map = thatMap,
            --slotData = slotData
        }))

        --if tracked then
        --    local _, _, questZoneIndex = GetJournalQuestLocationInfo(slotIndex)
        --    local questZoneId = GetZoneId(questZoneIndex)
        --    if questZoneId ~= 0 then
        --        -- get exact quest location
        --        questZoneId = BMU.findExactQuestLocation(slotIndex)
        --    end
        --    BMU.sc_porting(questZoneId)
        --end
    end

    self.list = list -- Keep a copy for debugging

    return list
end

function Quest:GetQuestZoneId(questIndex)
    --local questName, _, _, _, _, _, _ = GetJournalQuestInfo(questIndex)

    if self.cache[questIndex] ~= nil then
        -- Quest data did not change: use data from cache
        return self.cache[questIndex]["zoneId"]
    else
    --    -- Get location info
        local result = Quest.SetMapToQuest(questIndex)
        local questZoneId = GetZoneId(GetCurrentMapZoneIndex())
        local mapId = GetCurrentMapId()
    --    -- set map back to player location
        SetMapToPlayerLocation()
        --CALLBACK_MANAGER:FireCallbacks("OnWorldMapChanged")
    --
    --    -- save location data into cache
        self.cache[questIndex] = {}
        self.cache[questIndex]["zoneId"] = questZoneId
    --
        return questZoneId, mapId
    end
end

function Quest.ClearCache()
    Quest.cache = {}
end

-- set map to actual quest location depending on the active step and conditions
-- code is based on the function "ZO_WorldMap_ShowQuestOnMap(questIndex)"
-- https://esoapi.uesp.net/100028/src/ingame/map/worldmap.lua.html#6838
function Quest.SetMapToQuest(questIndex)
    --first try to set the map to one of the quest's step pins
    local result = SET_MAP_RESULT_FAILED
    for stepIndex = QUEST_MAIN_STEP_INDEX, GetJournalQuestNumSteps(questIndex) do
        --Loop through the conditions, if there are any. Prefer non-completed conditions to completed ones.
        local requireNotCompleted = true
        local conditionsExhausted = false
        while result == SET_MAP_RESULT_FAILED and not conditionsExhausted do
            for conditionIndex = 1, GetJournalQuestNumConditions(questIndex, stepIndex) do
                local tryCondition = true
                if requireNotCompleted then
                    local complete = select(4, GetJournalQuestConditionValues(questIndex, stepIndex, conditionIndex))
                    tryCondition = not complete
                end
                if tryCondition then
                    result = SetMapToQuestCondition(questIndex, stepIndex, conditionIndex)
                    if result ~= SET_MAP_RESULT_FAILED then
                        break
                    end
                end
            end
            if requireNotCompleted then
                requireNotCompleted = false
            else
                conditionsExhausted = true
            end
        end
        if result ~= SET_MAP_RESULT_FAILED then
            break
        end
        --If it's the end, set the map to the ending location (Endings don't have conditions)
        if IsJournalQuestStepEnding(questIndex, stepIndex) then
            result = SetMapToQuestStepEnding(questIndex, stepIndex)
            if result ~= SET_MAP_RESULT_FAILED then
                break
            end
        end
    end
    --if it has no condition pins, set it to the quest's zone
    if result == SET_MAP_RESULT_FAILED then
        result = SetMapToQuestZone(questIndex)
    end
    --if that doesn't work, bail
    if result == SET_MAP_RESULT_FAILED then
        --ZO_Alert(UI_ALERT_CATEGORY_ERROR, SOUNDS.NEGATIVE_CLICK, SI_WORLD_MAP_NO_QUEST_MAP_LOCATION)
        return nil
    end

    return result
end


--function Quest:New(o)
--    o = o or { list = {} }
--    setmetatable(o, self)
--    self.__index = self
--    return o
--end


Nav.QuestNode = QuestNode
Nav.Quest = Quest